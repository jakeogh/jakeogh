diff --git a/configure.ac b/configure.ac
index 31336fd..57b99e0 100644
--- a/configure.ac
+++ b/configure.ac
@@ -96,7 +96,7 @@ AS_IF([test "x$with_gtk3" != "xno"],
 )
 AM_CONDITIONAL([GTK3], [test x$USEGTK3 = xyes])
 
-dnl OpenGL/GtkGLExt
+dnl OpenGL (using GLX, requires libGL and X11)
 dnl Check by default, can be disabled
 dnl ---------------------------------
 AC_ARG_WITH([opengl],
@@ -105,15 +105,14 @@ AC_ARG_WITH([opengl],
                   [],
                   [with_opengl=check])
 AS_IF([test "x$with_opengl" != "xno"],
-      [PKG_CHECK_MODULES([GTKGLEXT], [gtkglext-3.0], [], [echo "Using software rendering"])
-       if $PKG_CONFIG --exists gtkglext-3.0 ; then
+      [AC_CHECK_LIB([GL], [glXCreateContext], [have_gl=yes], [have_gl=no])
+       if test "x$have_gl" = "xyes" ; then
          USEOPENGL="yes"
-         AC_DEFINE([OPENGL], [1], [Define to 1 if GtkGLExt/OpenGL dependent code is to be compiled.])
-         LIBS="$LIBS $GTKGLEXT_LIBS"
-         CPPFLAGS="$CPPFLAGS $GTKGLEXT_CFLAGS"
-         AC_SUBST(OPENGL_COND,[gtkglext-3.0])
+         AC_DEFINE([OPENGL], [1], [Define to 1 if OpenGL dependent code is to be compiled.])
+         LIBS="$LIBS -lGL"
+         AC_SUBST(OPENGL_COND,"")
        elif test "x$with_opengl" != "xcheck" ; then
-         AC_MSG_ERROR([--with-opengl was given, but pkgconfig check for gtkglext-3.0 library failed])
+         AC_MSG_ERROR([--with-opengl was given, but libGL was not found])
        else
          AC_SUBST(OPENGL_COND,"")
        fi]
diff --git a/src/glrenderer.cpp b/src/glrenderer.cpp
index 98ff7b4..cfcb919 100644
--- a/src/glrenderer.cpp
+++ b/src/glrenderer.cpp
@@ -42,47 +42,170 @@
 
 
 #include <GL/gl.h>
+#include <GL/glx.h>
+#include <gdk/gdkx.h>
 #include "glrenderer.hpp"
 #include "ibsimu.hpp"
 
+// Cast helpers for opaque types stored in header
+#define XDISPLAY  ((Display *)_xdisplay)
+#define XWINDOW   ((Window)_xwindow)
+
 
 GLRenderer::GLRenderer( GtkWidget *darea )
     : _darea(darea),
+      _xdisplay(NULL),
+      _glx_context(NULL),
+      _xwindow(0),
+      _gl_ready(false),
       _material_diffuse_color(0.8,0.0,0.0), 
       _material_ambient_color(0.2,0.0,0.0),
       _color(0.0,0.0,0.0)
 {
-    GdkGLConfigMode mode = (GdkGLConfigMode)( GDK_GL_MODE_RGBA |
-					      GDK_GL_MODE_DEPTH |
-					      GDK_GL_MODE_DOUBLE );
-    GdkGLConfig *gl_config = gdk_gl_config_new_by_mode( mode );
-    if( !gl_config )
-        throw( ErrorGLInit() );
-
-    if( !gtk_widget_set_gl_capability( darea, gl_config, NULL, TRUE,
-				       GDK_GL_RGBA_TYPE ) )
-        throw( ErrorGLInit() );
-
-    ibsimu.message( 1 ) << "Using GLRenderer\n";
+    ibsimu.message( 1 ) << "Using GLRenderer (GLX compat)\n";
     ibsimu.flush();
 }
 
 
 GLRenderer::~GLRenderer()
 {
+    if( _glx_context ) {
+	glXMakeCurrent( XDISPLAY, None, NULL );
+	glXDestroyContext( XDISPLAY, _glx_context );
+    }
+}
+
+
+#ifndef GLX_CONTEXT_MAJOR_VERSION_ARB
+#define GLX_CONTEXT_MAJOR_VERSION_ARB      0x2091
+#define GLX_CONTEXT_MINOR_VERSION_ARB      0x2092
+#define GLX_CONTEXT_PROFILE_MASK_ARB       0x9126
+#define GLX_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB 0x00000002
+#endif
+
+typedef GLXContext (*glXCreateContextAttribsARBProc)(Display*, GLXFBConfig, GLXContext, Bool, const int*);
 
+void GLRenderer::init_gl( void )
+{
+    GdkWindow *gdk_win = gtk_widget_get_window( _darea );
+    if( !gdk_win )
+	return;
+
+    _xdisplay = (void *)gdk_x11_display_get_xdisplay( gdk_display_get_default() );
+    _xwindow = (unsigned long)gdk_x11_window_get_xid( gdk_win );
+    Display *dpy = XDISPLAY;
+    Window xwin = XWINDOW;
+    int screen = DefaultScreen( dpy );
+
+    // Get visual of existing window
+    XWindowAttributes xwa;
+    XGetWindowAttributes( dpy, xwin, &xwa );
+    VisualID target_vid = XVisualIDFromVisual( xwa.visual );
+
+    // Find FBConfig matching window visual with depth buffer
+    int fb_attribs[] = {
+	GLX_RENDER_TYPE, GLX_RGBA_BIT,
+	GLX_DRAWABLE_TYPE, GLX_WINDOW_BIT,
+	GLX_DOUBLEBUFFER, True,
+	GLX_DEPTH_SIZE, 16,
+	None
+    };
+    int nfb = 0;
+    GLXFBConfig *fbcs = glXChooseFBConfig( dpy, screen, fb_attribs, &nfb );
+    GLXFBConfig matching_fbc = NULL;
+
+    if( fbcs ) {
+	for( int i = 0; i < nfb; i++ ) {
+	    XVisualInfo *vi = glXGetVisualFromFBConfig( dpy, fbcs[i] );
+	    if( vi && vi->visualid == target_vid ) {
+		matching_fbc = fbcs[i];
+		XFree( vi );
+		break;
+	    }
+	    if( vi ) XFree( vi );
+	}
+
+	// Fallback: if no depth-capable FBConfig matches, try without depth
+	if( !matching_fbc ) {
+	    int fb_attribs2[] = {
+		GLX_RENDER_TYPE, GLX_RGBA_BIT,
+		GLX_DRAWABLE_TYPE, GLX_WINDOW_BIT,
+		GLX_DOUBLEBUFFER, True,
+		None
+	    };
+	    int nfb2 = 0;
+	    GLXFBConfig *fbcs2 = glXChooseFBConfig( dpy, screen, fb_attribs2, &nfb2 );
+	    if( fbcs2 ) {
+		for( int i = 0; i < nfb2; i++ ) {
+		    XVisualInfo *vi = glXGetVisualFromFBConfig( dpy, fbcs2[i] );
+		    if( vi && vi->visualid == target_vid ) {
+			matching_fbc = fbcs2[i];
+			XFree( vi );
+			break;
+		    }
+		    if( vi ) XFree( vi );
+		}
+		XFree( fbcs2 );
+	    }
+	}
+	XFree( fbcs );
+    }
+
+    // Try glXCreateContextAttribsARB for explicit compat profile
+    glXCreateContextAttribsARBProc glXCreateContextAttribsARB =
+	(glXCreateContextAttribsARBProc)glXGetProcAddressARB(
+	    (const GLubyte *)"glXCreateContextAttribsARB" );
+
+    if( matching_fbc && glXCreateContextAttribsARB ) {
+	int ctx_attribs[] = {
+	    GLX_CONTEXT_MAJOR_VERSION_ARB, 3,
+	    GLX_CONTEXT_MINOR_VERSION_ARB, 0,
+	    GLX_CONTEXT_PROFILE_MASK_ARB, GLX_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB,
+	    None
+	};
+	_glx_context = glXCreateContextAttribsARB( dpy, matching_fbc,
+						   NULL, True, ctx_attribs );
+    }
+
+    // Fallback: old-style glXCreateContext (compat by default)
+    if( !_glx_context ) {
+	XVisualInfo tmpl;
+	tmpl.visualid = target_vid;
+	int nitems;
+	XVisualInfo *vi = XGetVisualInfo( dpy, VisualIDMask, &tmpl, &nitems );
+	if( vi ) {
+	    _glx_context = glXCreateContext( dpy, vi, NULL, True );
+	    XFree( vi );
+	}
+    }
+
+    if( !_glx_context ) {
+	ibsimu.message( 1 ) << "Failed to create GLX context\n";
+	ibsimu.flush();
+	return;
+    }
+
+    glXMakeCurrent( dpy, xwin, _glx_context );
+
+    const char *version = (const char *)glGetString( GL_VERSION );
+    const char *renderer = (const char *)glGetString( GL_RENDERER );
+    ibsimu.message( 1 ) << "GLX context: " << (version ? version : "NULL")
+			 << " renderer=" << (renderer ? renderer : "NULL") << "\n";
+    ibsimu.flush();
+
+    _gl_ready = true;
 }
 
 
 void GLRenderer::start_rendering( void )
 {
-    // Initialize OpenGL context
-    _glcontext = gtk_widget_get_gl_context( _darea );
-    _gldrawable = gtk_widget_get_gl_drawable( _darea );
-    if( !gdk_gl_drawable_gl_begin( _gldrawable, _glcontext ) )
-	g_assert_not_reached();
+    if( !_gl_ready )
+	init_gl();
+    if( !_gl_ready )
+	return;
+
+    glXMakeCurrent( XDISPLAY, XWINDOW, _glx_context );
 
-    // Set OpenGL viewport
     GtkAllocation alloc;
     gtk_widget_get_allocation( _darea, &alloc );
     glViewport( 0, 0, alloc.width, alloc.height );
@@ -100,12 +223,9 @@ void GLRenderer::start_rendering( void )
 
 void GLRenderer::end_rendering( cairo_t *cairo )
 {
-    // Finish draw and close OpenGL context
-    if( gdk_gl_drawable_is_double_buffered( _gldrawable) )
-        gdk_gl_drawable_swap_buffers( _gldrawable ); 
-    else
-        glFlush();
-    gdk_gl_drawable_gl_end( _gldrawable );
+    if( !_gl_ready )
+	return;
+    glXSwapBuffers( XDISPLAY, XWINDOW );
 }
 
 
diff --git a/src/glrenderer.hpp b/src/glrenderer.hpp
index 5064b35..18294cc 100644
--- a/src/glrenderer.hpp
+++ b/src/glrenderer.hpp
@@ -45,34 +45,32 @@
 #define GLRENDERER_HPP 1
 
 
-#include <gtk/gtkgl.h>
+#include <gtk/gtk.h>
+#include <GL/gl.h>
 #include "renderer.hpp"
-#include "error.hpp"
 
 
-/*! \brief OpenGL 3D renderer.
+// Opaque GLX types to avoid X11 header pollution (Colormap typedef conflict)
+typedef struct __GLXcontextRec *GLXContext;
+
+
+/*! \brief OpenGL 3D renderer using GLX compatibility profile.
  */
 class GLRenderer : public Renderer {
 
     GtkWidget      *_darea;
-    GdkGLContext   *_glcontext;
-    GdkGLDrawable  *_gldrawable;
+    void           *_xdisplay;    // Display*
+    GLXContext      _glx_context;
+    unsigned long   _xwindow;     // Window (XID)
+    bool            _gl_ready;
 
     Vec3D            _material_diffuse_color;
     Vec3D            _material_ambient_color;
     Vec3D            _color;
 
-public:
+    void init_gl( void );
 
-    /*! \brief Class for OpenGL initialization error.
-     */
-    class ErrorGLInit : public Error {	
-    public:
-
-	/*! \brief Error constructor.
-	 */
-	ErrorGLInit() {}
-    };
+public:
 
     GLRenderer( GtkWidget *darea );
     virtual ~GLRenderer();
diff --git a/src/gtkgeom3dwindow.cpp b/src/gtkgeom3dwindow.cpp
index a678ebe..e3f2c36 100644
--- a/src/gtkgeom3dwindow.cpp
+++ b/src/gtkgeom3dwindow.cpp
@@ -96,19 +96,11 @@ void GTKGeom3DWindow::init_renderer( void )
 {
 #ifdef OPENGL
     if( _plotter.opengl() ) {
-	try {
-	    // Try initializing OpenGL renderer
-	    _renderer = new GLRenderer( _darea );
-	} catch( GLRenderer::ErrorGLInit e ) {
-	    // Fallback to software renderer
-	    _renderer = new SoftwareRenderer( _darea );
-	}
+	_renderer = new GLRenderer( _darea );
     } else {
-	// No GdkGLExt initialized
 	_renderer = new SoftwareRenderer( _darea );
     }
 #else
-    // Only software renderer available
     _renderer = new SoftwareRenderer( _darea );
 #endif
 }
@@ -280,6 +272,9 @@ void GTKGeom3DWindow::init_window( void )
     g_signal_connect( G_OBJECT(_darea), "button_release_event",
 		      G_CALLBACK(darea_button_signal),
 		      (gpointer)this );
+    g_signal_connect( G_OBJECT(_darea), "scroll_event",
+		      G_CALLBACK(darea_scroll_signal),
+		      (gpointer)this );
     g_signal_connect( G_OBJECT(_darea), "motion_notify_event",
 		      G_CALLBACK(darea_motion_signal),
 		      (gpointer)this );
@@ -792,6 +787,19 @@ gboolean GTKGeom3DWindow::darea_button_signal( GtkWidget *widget,
 }
 
 
+gboolean GTKGeom3DWindow::darea_scroll_signal( GtkWidget *widget,
+					       GdkEventScroll *event,
+					       gpointer object )
+{
+    GTKGeom3DWindow *window = (GTKGeom3DWindow *)object;
+    if( event->direction == GDK_SCROLL_UP )
+	window->zoom_in( event->x, event->y );
+    else if( event->direction == GDK_SCROLL_DOWN )
+	window->zoom_out( event->x, event->y );
+    return( TRUE );
+}
+
+
 gboolean GTKGeom3DWindow::window_delete_signal( GtkWidget *widget, 
 						GdkEventExpose *event, 
 						gpointer object )
diff --git a/src/gtkgeom3dwindow.hpp b/src/gtkgeom3dwindow.hpp
index 82f9d41..83cfe9c 100644
--- a/src/gtkgeom3dwindow.hpp
+++ b/src/gtkgeom3dwindow.hpp
@@ -135,6 +135,9 @@ class GTKGeom3DWindow : public GTKWindow {
     static gboolean darea_button_signal( GtkWidget *widget, 
 					 GdkEventButton *event,
 					 gpointer object );
+    static gboolean darea_scroll_signal( GtkWidget *widget,
+					 GdkEventScroll *event,
+					 gpointer object );
     static gboolean darea_motion_signal( GtkWidget *widget, 
 					 GdkEventMotion *event,
 					 gpointer object );
diff --git a/src/gtkplotter.cpp b/src/gtkplotter.cpp
index 6a975a2..fcc694e 100644
--- a/src/gtkplotter.cpp
+++ b/src/gtkplotter.cpp
@@ -43,10 +43,6 @@
 
 #include "config.h"
 
-#ifdef OPENGL
-#include <gtk/gtkgl.h>
-#endif
-
 #include "gtkplotter.hpp"
 #include "gtkgeomwindow.hpp"
 #include "gtkgeom3dwindow.hpp"
@@ -74,10 +70,6 @@ GTKPlotter::GTKPlotter( int *argc, char ***argv )
 
 #ifdef OPENGL
 	_opengl = true;
-	// Initialize OpenGL
-	if( gtk_gl_init_check( argc, argv ) == FALSE ||
-	    gdk_gl_query_extension() == FALSE )
-	    _opengl = false;
 #endif
     }
 }
